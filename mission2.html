<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>문어 스크래치</title>
    <style>
        /* 'Gaegu' 폰트 */
        @import url('https://fonts.googleapis.com/css2?family=Gaegu&display=swap');

        /* 기본 스타일 */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* 스크롤 방지 */
            /* 기본 폰트를 'Gaegu'로 설정 */
            font-family: 'Gaegu', cursive; /* 적용된 폰트 */
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* 텍스트 섹션 스타일 */
        #text-section {
            padding: 30px 20px;
            text-align: center;
            font-size: 1.5em; /* 폰트 크기 조정 */
            line-height: 1.6;
            color: #333;
            background-color: #fff;
        }

        /* 에너지바 섹션 스타일 */
        #progress-section {
            padding: 20px;
            text-align: center;
            background-color: #fff;
            border-top: 1px solid #eee; /* 텍스트 섹션과 구분선 */
        }

        #progress-bar-container {
            width: 80%;
            max-width: 600px;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 15px;
            margin: auto;
            overflow: hidden;
            border: 2px solid #ccc;
        }

        #progress-bar {
            width: 0%; /* 시작은 0% */
            height: 100%;
            background-color: #4caf50; /* 초록색 바 */
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
            font-size: 1em;
            transition: width 0.1s linear; /* smoother, faster transition */
        }
        
        /* 스크래치 영역 스타일 */
        #scratch-section {
            position: relative;
            width: 100%;
            margin: auto;
            overflow: hidden;
            flex-grow: 1; /* 남은 공간을 모두 차지 */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eaf8ff; /* 이미지 로딩 전 배경색 */
        }

        #bg-img {
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* 이미지가 영역에 맞춰 비율 유지 */
        }

        #scratch-canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; /* 모바일 터치 스크롤 방지 */
        }
    </style>
</head>
<body>

    <div id="text-section">
        상실감이 큰 문어의 마음을<br>
        계속 어루만져주면<br>
        문어의 이야기를 들을 수 있을거야.
    </div>

    <div id="progress-section">
        <div id="progress-bar-container">
            <div id="progress-bar">0%</div>
        </div>
    </div>

    <div id="scratch-section">
        <img id="bg-img" src="images/mission2/문어알.png" alt="배경 이미지" />
        <canvas id="scratch-canvas"></canvas>
    </div>

    <script>
        // --- 설정 변수 ---
        const OVERLAY_IMAGE_SRC = "images/mission2/문어의마음.jpg";
        const REDIRECT_URL = "room2.html";
        const COMPLETION_THRESHOLD = 96;

        // --- DOM 요소 가져오기 ---
        const bgImg = document.getElementById("bg-img");
        const canvas = document.getElementById("scratch-canvas");
        const progressBar = document.getElementById("progress-bar");
        const ctx = canvas.getContext("2d");

        // --- 스크래치 영역 좌표 (원본 이미지 기준) ---
        const scratchRect = { x: 498, y: 1016, w: 926 - 498, h: 1484 - 1016 };
        
        // --- 상태 변수 ---
        let scaledRect = {};
        let isDrawing = false;
        let isCompleted = false;

        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 100; // 100ms (0.1초) 마다 업데이트하여 부하를 줄임

        // --- 오버레이 이미지 로딩 ---
        const overlayImg = new Image();
        overlayImg.src = OVERLAY_IMAGE_SRC;
        
        bgImg.onload = initializeCanvas;
        overlayImg.onload = initializeCanvas;
        
        // --- 캔버스 초기화 및 리사이즈 함수 ---
        function initializeCanvas() {
            if (!bgImg.complete || !overlayImg.complete) {
                return;
            }

            const container = document.getElementById('scratch-section');
            const containerRatio = container.clientWidth / container.clientHeight;
            const imgRatio = bgImg.naturalWidth / bgImg.naturalHeight;
            
            let imgWidth, imgHeight;

            if (containerRatio > imgRatio) {
                imgHeight = container.clientHeight;
                imgWidth = imgHeight * imgRatio;
            } else {
                imgWidth = container.clientWidth;
                imgHeight = imgWidth / imgRatio;
            }
            
            canvas.width = imgWidth;
            canvas.height = imgHeight;
            
            const topOffset = (container.clientHeight - imgHeight) / 2;
            const leftOffset = (container.clientWidth - imgWidth) / 2;
            canvas.style.top = `${topOffset}px`;
            canvas.style.left = `${leftOffset}px`;
            
            bgImg.style.width = `${imgWidth}px`;
            bgImg.style.height = `${imgHeight}px`;
            bgImg.style.position = 'absolute';
            bgImg.style.top = `${topOffset}px`;
            bgImg.style.left = `${leftOffset}px`;

            const scaleRatio = imgWidth / bgImg.naturalWidth;
            scaledRect = {
                x: Math.floor(scratchRect.x * scaleRatio),
                y: Math.floor(scratchRect.y * scaleRatio),
                w: Math.floor(scratchRect.w * scaleRatio),
                h: Math.floor(scratchRect.h * scaleRatio)
            };
            
            ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);
        }
        
        // --- 좌표 계산 함수 ---
        function getPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            return {
                x: (clientX - rect.left),
                y: (clientY - rect.top)
            };
        }

        // --- 스크래치 영역 내부인지 확인하는 함수 ---
        function isInScratchArea(x, y) {
            return (
                x >= scaledRect.x && x <= scaledRect.x + scaledRect.w &&
                y >= scaledRect.y && y <= scaledRect.y + scaledRect.h
            );
        }

        // --- 긁기 시작 ---
        function startScratch(event) {
            event.preventDefault();
            const { x, y } = getPosition(event);
            if (isInScratchArea(x, y)) {
                isDrawing = true;
                scratch(event);
            }
        }
        
        // --- 긁는 중 ---
        function scratch(event) {
            if (!isDrawing) return;
            event.preventDefault();
            const { x, y } = getPosition(event);
            
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, 2 * Math.PI);
            ctx.fill();

            const now = Date.now();
            if (now - lastUpdateTime > UPDATE_INTERVAL) {
                updateProgress();
                lastUpdateTime = now;
            }
        }

        // --- 긁기 종료 ---
        function endScratch() {
            if (!isDrawing) return;
            isDrawing = false;
            updateProgress();
        }

        // --- 진행률 업데이트 함수 ---
        function updateProgress() {
            if (isCompleted) return;

            const imageData = ctx.getImageData(scaledRect.x, scaledRect.y, scaledRect.w, scaledRect.h);
            const pixels = imageData.data;
            let transparentPixels = 0;

            for (let i = 3; i < pixels.length; i += 4) {
                if (pixels[i] < 128) {
                    transparentPixels++;
                }
            }

            const totalPixels = scaledRect.w * scaledRect.h;
            let percent = totalPixels > 0 ? Math.round((transparentPixels / totalPixels) * 100) : 0;

            if (percent >= COMPLETION_THRESHOLD) {
                percent = 100;
                isCompleted = true; 
                
                progressBar.style.width = '100%';
                progressBar.innerText = '100%';
                
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 500);

            } else {
                progressBar.style.width = percent + '%';
                progressBar.innerText = percent + '%';
            }
        }

        // --- 이벤트 리스너 등록 ---
        canvas.addEventListener('mousedown', startScratch);
        canvas.addEventListener('mousemove', scratch);
        document.addEventListener('mouseup', endScratch);
        canvas.addEventListener('mouseleave', endScratch);

        canvas.addEventListener('touchstart', startScratch, { passive: false });
        canvas.addEventListener('touchmove', scratch, { passive: false });
        canvas.addEventListener('touchend', endScratch);
        
        window.addEventListener('resize', initializeCanvas);
        window.addEventListener('load', initializeCanvas);
    </script>

</body>
</html>
