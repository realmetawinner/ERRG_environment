<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>문어 스크래치</title>
    <style>
        /* 기본 스타일 */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* 스크롤 방지 */
            font-family: sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* 에너지바 섹션 스타일 */
        #progress-section {
            padding: 20px;
            text-align: center;
            background-color: #fff;
        }

        #progress-bar-container {
            width: 80%;
            max-width: 600px;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 15px;
            margin: auto;
            overflow: hidden;
            border: 2px solid #ccc;
        }

        #progress-bar {
            width: 0%; /* 시작은 0% */
            height: 100%;
            background-color: #4caf50; /* 초록색 바 */
            text-align: center;
            line-height: 30px;
            color: white;
            font-weight: bold;
            transition: width 0.3s ease-in-out; /* 부드러운 전환 효과 */
        }
        
        /* 스크래치 영역 스타일 */
        #scratch-section {
            position: relative;
            width: 100%;
            max-width: 1080px; /* 이미지 최대 너비에 맞춤 */
            margin: auto;
            overflow: hidden;
            flex-grow: 1; /* 남은 공간을 모두 차지 */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #bg-img {
            display: block;
            width: 100%;
            height: auto;
        }

        #scratch-canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none; /* 모바일 터치 스크롤 방지 */
        }
    </style>
</head>
<body>

    <div id="progress-section">
        <div id="progress-bar-container">
            <div id="progress-bar">0%</div>
        </div>
    </div>

    <div id="scratch-section">
        <img id="bg-img" src="문어알.png" alt="배경 이미지" />
        <canvas id="scratch-canvas"></canvas>
    </div>

    <script>
        // --- 설정 변수 ---
        const OVERLAY_IMAGE_SRC = "문어의마음.jpg"; // 긁어낼 앞면 이미지
        const REDIRECT_URL = "room2.html";      // 완료 후 이동할 페이지
        const COMPLETION_THRESHOLD = 96;        // 완료로 간주할 퍼센트 (96%)

        // --- DOM 요소 가져오기 ---
        const bgImg = document.getElementById("bg-img");
        const canvas = document.getElementById("scratch-canvas");
        const progressBar = document.getElementById("progress-bar");
        const ctx = canvas.getContext("2d");

        // --- 스크래치 영역 좌표 (원본 이미지 기준) ---
        const scratchRect = { x: 498, y: 1016, w: 926 - 498, h: 1484 - 1016 };
        
        // --- 상태 변수 ---
        let scaledRect = {}; // 화면 크기에 맞게 조절된 좌표
        let isDrawing = false;
        let isCompleted = false;
        
        // --- 오버레이 이미지 로딩 ---
        const overlayImg = new Image();
        overlayImg.src = OVERLAY_IMAGE_SRC;
        // 이미지가 로드된 후에 캔버스 초기화 실행
        overlayImg.onload = initializeCanvas;
        
        // --- 캔버스 초기화 및 리사이즈 함수 ---
        function initializeCanvas() {
            const container = document.getElementById('scratch-section');
            const ratio = bgImg.naturalWidth / bgImg.naturalHeight;
            let newWidth, newHeight;

            // 컨테이너 비율에 맞춰 이미지 크기 계산
            if (container.clientWidth / container.clientHeight > ratio) {
                newHeight = container.clientHeight;
                newWidth = newHeight * ratio;
            } else {
                newWidth = container.clientWidth;
                newHeight = newWidth / ratio;
            }
            
            bgImg.style.width = `${newWidth}px`;
            bgImg.style.height = `${newHeight}px`;

            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // 캔버스 위치 조정 (이미지 중앙 정렬)
            const topOffset = (container.clientHeight - newHeight) / 2;
            const leftOffset = (container.clientWidth - newWidth) / 2;
            canvas.style.top = `${topOffset}px`;
            canvas.style.left = `${leftOffset}px`;

            // 스크래치 영역 좌표를 현재 이미지 크기에 맞게 재계산
            const scaleRatio = newWidth / bgImg.naturalWidth;
            scaledRect = {
                x: Math.floor(scratchRect.x * scaleRatio),
                y: Math.floor(scratchRect.y * scaleRatio),
                w: Math.floor(scratchRect.w * scaleRatio),
                h: Math.floor(scratchRect.h * scaleRatio)
            };
            
            // 캔버스에 오버레이 이미지 그리기
            ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);
        }
        
        // --- 좌표 계산 함수 ---
        function getPosition(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            if (event.touches) { // 모바일 터치
                return {
                    x: (event.touches[0].clientX - rect.left) * scaleX,
                    y: (event.touches[0].clientY - rect.top) * scaleY
                };
            } else { // PC 마우스
                return {
                    x: (event.clientX - rect.left) * scaleX,
                    y: (event.clientY - rect.top) * scaleY
                };
            }
        }

        // --- 스크래치 영역 내부인지 확인하는 함수 ---
        function isInScratchArea(x, y) {
            return (
                x >= scaledRect.x && x <= scaledRect.x + scaledRect.w &&
                y >= scaledRect.y && y <= scaledRect.y + scaledRect.h
            );
        }

        // --- 긁기 시작 ---
        function startScratch(event) {
            event.preventDefault();
            const { x, y } = getPosition(event);
            if (isInScratchArea(x, y)) {
                isDrawing = true;
                scratch(event);
            }
        }
        
        // --- 긁는 중 ---
        function scratch(event) {
            if (!isDrawing) return;
            event.preventDefault();
            const { x, y } = getPosition(event);
            
            // 원을 그려서 긁어내는 효과
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(x, y, 20, 0, 2 * Math.PI); // 긁는 원의 반지름 20px
            ctx.fill();
        }

        // --- 긁기 종료 및 진행률 업데이트 ---
        function endScratch() {
            if (!isDrawing) return;
            isDrawing = false;
            updateProgress();
        }

        // --- 진행률 업데이트 함수 ---
        function updateProgress() {
            if (isCompleted) return;

            const imageData = ctx.getImageData(scaledRect.x, scaledRect.y, scaledRect.w, scaledRect.h);
            const pixels = imageData.data;
            let transparentPixels = 0;

            // 알파 채널(투명도) 값을 확인하여 긁힌 픽셀 수 계산
            for (let i = 3; i < pixels.length; i += 4) {
                if (pixels[i] === 0) {
                    transparentPixels++;
                }
            }

            const totalPixels = scaledRect.w * scaledRect.h;
            let percent = Math.round((transparentPixels / totalPixels) * 100);

            // 96% 이상이면 100%로 처리
            if (percent >= COMPLETION_THRESHOLD) {
                percent = 100;
                isCompleted = true; // 중복 실행 방지
                
                progressBar.style.width = '100%';
                progressBar.innerText = '100%';
                
                // 0.5초 후 다음 페이지로 이동
                setTimeout(() => {
                    window.location.href = REDIRECT_URL;
                }, 500);

            } else {
                progressBar.style.width = percent + '%';
                progressBar.innerText = percent + '%';
            }
        }

        // --- 이벤트 리스너 등록 ---
        // PC 마우스 이벤트
        canvas.addEventListener('mousedown', startScratch);
        canvas.addEventListener('mousemove', scratch);
        canvas.addEventListener('mouseup', endScratch);
        canvas.addEventListener('mouseleave', endScratch);

        // 모바일 터치 이벤트
        canvas.addEventListener('touchstart', startScratch, { passive: false });
        canvas.addEventListener('touchmove', scratch, { passive: false });
        canvas.addEventListener('touchend', endScratch);
        
        // 창 크기가 변경될 때 캔버스 크기 재조정
        window.addEventListener('resize', initializeCanvas);
    </script>

</body>
</html>
